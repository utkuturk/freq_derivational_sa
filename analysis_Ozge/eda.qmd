---
title: "Descriptive Plots, Modelling without Frequency, and Model Comparison"
author: Eva, Utku, Özge
format:
  html:
    self-contained: true  # ensures everything is embedded, no extra folders
    embed-resources: true
    fig-width: 12
    smooth-scroll: true
    code-copy: true
    code-fold: true
    code-summary: "Show the code"
    code-overflow: wrap
    toc: true             # adds table of contents
    toc-location: left    # optional: move TOC to left side
    toc-depth: 3          # optional: control how deep the TOC goes
    number-sections: true # adds numbering to sections
    theme: flatly          # or use another Bootstrap theme like journal, flatly, etc.
    highlight-style: a11y # accessible syntax highlighting
    # css: styles.css       # optional: your custom CSS if needed
---


## Setup: load packages and scripts and data


```{r, warning=FALSE, message=FALSE}
# packages
invisible(lapply(c("dplyr", "ggplot2", "tidyr", "readr", "purrr", "stringr", "knitr", "brms", "tidybayes", "loo"), library, character.only = TRUE))


# load scripts
invisible(lapply(list.files("./scripts", "\\.R$", full.names = TRUE), source))

# load data
exp <- read_csv("./data/exp_data.csv") 
filler_q <- read_csv("./data/filler_q.csv")
filler_scale <- read_csv("./data/filler_scale.csv")
```

## Overall Rating Counts by Condition

```{r, warning=FALSE, message=FALSE}
exp <- exp %>%
  mutate(
    suffix = factor(suffix, levels = sort(unique(suffix))),
    is_sa = factor(is_sa, levels = c(0, 1), labels = c("Not Suspended", "Suspended")),
    rating = factor(rating, levels = sort(unique(rating), decreasing = TRUE))
  )

summary_data <- exp %>%
  count(suffix, is_sa, rating, name = "count")

ggplot(summary_data, aes(x = is_sa, y = count, fill = rating)) +
  geom_bar(stat = "identity", position = "fill", color = "black", width = 0.8) +
  geom_text(
    aes(label = rating),
    stat = "identity",
    position = position_fill(vjust = 0.5),
    color = "white", fontface = "bold", size = 4
  ) +
  scale_fill_brewer(palette = "Spectral", direction = 1) + 
  scale_y_continuous(labels = NULL, breaks = NULL) +
  labs(
    x = "Suspension",
    y = NULL,
    fill = "Rating",
    title = "Cumulative Rating Distribution by Suspension and Suffix"
  ) +
  facet_wrap(~ suffix, ncol= 4) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.text.x = element_text(size = 12, face = "bold"),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 13, face = "bold"),
    plot.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 12, face = "bold")
  )

```


## Overall Rating Means by Condition

**Beware that I am treating ordinal values continuous, this is just to give you an idea**

```{r, warning=FALSE, message=FALSE}
summary_df <- exp %>%
  group_by(suffix, is_sa) %>%
  summarise(
    mean_rating = mean(as.numeric(as.character(rating)), na.rm = TRUE),
    se = sd(as.numeric(as.character(rating)), na.rm = TRUE) / sqrt(n()),
    n = n(),
    .groups = "drop"
  ) %>%
  mutate(ci = 1.96 * se)

ggplot(summary_df, aes(x = suffix, y = mean_rating, group = factor(is_sa),
                       shape = factor(is_sa), linetype = factor(is_sa))) +
  geom_point(position = position_dodge(width = 0.3), size = 3) +
  geom_errorbar(aes(ymin = mean_rating - ci, ymax = mean_rating + ci),
                position = position_dodge(width = 0.3), width = 0.2) +
  labs(x = "Suffix", y = "Mean Rating", shape = "Suspended", linetype = "Suspended") +
  theme_minimal()
```

## By subject plots for ratings

```{r, warning=FALSE, message=FALSE}
exp <- exp %>%
  group_by(completionCode) %>%
  mutate(subject = paste0("S", cur_group_id())) %>%
  ungroup()

# Summary data
summary_data <- exp %>%
  count(subject, suffix, is_sa, rating, name = "count")

summary_data_adjusted <- summary_data %>%
  group_by(subject, suffix, is_sa) %>%
  mutate(
    cumulative_count = cumsum(count) / sum(count),
    middle_of_bar = (cumsum(count) - count / 2) / sum(count)
  ) %>%
  ungroup()
```

::: {.panel-tabset}

```{r}
#| echo: false
#| output: asis

subject_ids <- unique(summary_data$subject)
subject_groups <- split(subject_ids, ceiling(seq_along(subject_ids) / 8))


for (i in seq_along(subject_groups)) {
  group_subjects <- subject_groups[[i]]
  title <- paste0(group_subjects[1], "–", group_subjects[length(group_subjects)])
  cat(paste0("### ", title, " {.tab}\n\n"))

  plot_data <- summary_data %>% filter(subject %in% group_subjects)
  label_data <- summary_data_adjusted %>% filter(subject %in% group_subjects)

  p <- ggplot(plot_data, aes(x = suffix, y = count, fill = rating)) +
    geom_bar(stat = "identity", position = "fill", color = "black", width = 0.8) +
    scale_fill_brewer(palette = "Spectral", direction = -1) +
    facet_wrap(~ subject + is_sa, ncol = 4) +  
    scale_y_continuous(labels = NULL, breaks = NULL) +
    labs(
      x = "Suffix",
      y = NULL,
      fill = "Rating"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 8, face = "bold"),
      axis.text.y = element_blank(),
      strip.text = element_text(size = 8, face = "bold")
    )

  print(p)
  cat("\n\n")
}

```
:::


## By item plots for ratings

```{r}
exp <- exp %>%
  group_by(itemNum) %>%
  mutate(item = paste0("I", cur_group_id())) %>%
  ungroup()

# Summary data
summary_data <- exp %>%
  count(item, suffix, is_sa, rating, name = "count")

summary_data_adjusted <- summary_data %>%
  group_by(item, suffix, is_sa) %>%
  mutate(
    cumulative_count = cumsum(count) / sum(count),
    middle_of_bar = (cumsum(count) - count / 2) / sum(count)
  ) %>%
  ungroup()

```

::: {.panel-tabset}

```{r}
#| echo: false
#| output: asis
# Re-split into groups of 8
item_ids <- unique(summary_data$item)
item_groups <- split(item_ids, ceiling(seq_along(item_ids) / 8))


for (i in seq_along(item_groups)) {
  group_items <- item_groups[[i]]
  title <- paste0(group_items[1], "–", group_items[length(group_items)])
  cat(paste0("### ", title, " {.tab}\n\n"))

  plot_data <- summary_data %>% filter(item %in% group_items)
  label_data <- summary_data_adjusted %>% filter(item %in% group_items)

  p <- ggplot(plot_data, aes(x = suffix, y = count, fill = rating)) +
    geom_bar(stat = "identity", position = "fill", color = "black", width = 0.8) +
    scale_fill_brewer(palette = "Spectral", direction = -1) +
    facet_wrap(~ item + is_sa, ncol = 4) +  
    scale_y_continuous(labels = NULL, breaks = NULL) +
    labs(
      x = "Suffix",
      y = NULL,
      fill = "Rating"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 8, face = "bold"),
      axis.text.y = element_blank(),
      strip.text = element_text(size = 8, face = "bold")
    )

  print(p)
  cat("\n\n")
}

```
:::


## Modelling the data without Frequency

```{r, warning=FALSE, message=FALSE}

contrasts(exp$is_sa) <- contr.sum(2)/2  # centered contrast for suspension (.5 = Suspended, -.5 = Not Suspended)
exp$rating <- factor(exp$rating, ordered = TRUE)
exp$subject <- as.factor(exp$subject)
exp$itemNum <- as.factor(exp$itemNum)
my_prior <- c(
  prior(normal(0, 0.5), class = "b", coef = "is_sa1"),
  prior(exponential(1), class = "sd", group = "subject"),
  prior(exponential(1), class = "sd", group = "itemNum"),
  prior(exponential(1), class = "sd", coef = "is_sa1", group = "subject"),
  prior(lkj(2), class = "cor"),
  prior(normal(0, 5), class = "Intercept")
)


fit_model <- function(formula, data = exp, priors = my_prior, model_name, path = "./models") {

  terms_in_formula <- all.vars(as.formula(formula))
  formula_str <- deparse(formula)

  if (!is.null(priors)) {
    priors <- priors %>%
      filter(
        is.na(coef) |  
          coef != "is_sa1" | "is_sa" %in% terms_in_formula,
        !(class == "sd" & coef == "is_sa1" & !("is_sa" %in% terms_in_formula)),
        !(class == "cor" & !grepl("\\(1 \\+ .*\\|", formula_str))  
      )
  }

  brm(
    formula = formula,
    data = data,
    family = cumulative(link = "logit"),
    prior = priors,
    chains = 4, iter = 4000, cores = 4,
    control = list(adapt_delta = 0.95),
    file = file.path(path, model_name)
  )
}


##running clmm models

library(ordinal)
full_linear <- clmm(as.factor(rating) ~ is_sa * suffix + (1 | subject) + (1 | itemNum),
                    data = exp)
summary(full_linear)

nested_linear <- clmm(as.factor(rating) ~ suffix/is_sa + (1 | subject) + (1 | itemNum),
                    data = exp)
summary(nested_linear)

#deviation coding??

#bayesian models

# A: Full model
model_full <- fit_model(
  formula = rating ~ is_sa * suffix + (1 + is_sa * suffix| subject) + (1 + is_sa * suffix| itemNum),
  model_name = "model_full_prior"
)

# B: No interaction
model_no_interaction <- fit_model(
  formula = rating ~ is_sa + suffix + (1 + is_sa | subject) + (1 | itemNum),
  model_name = "model_no_interaction"
)

# C: No SA
model_no_sa <- fit_model(
  formula = rating ~ suffix + (1 | subject) + (1 | itemNum),
  model_name = "model_no_sa"
)

# D: No suffix
model_no_suffix <- fit_model(
  formula = rating ~ is_sa + (1 + is_sa | subject) + (1 | itemNum),
  model_name = "model_no_suffix"
)
# 
# is_sa * Coord (for each suffix separately)
# is_sa * csumPMI (for each suffix separately)
# is_sa * Coord * Suffix # run this no matter what
# is_sa * csumPMI * Suffix # run this no matter what
# Do not log them (freq), unless the models goes wrong
# add more specification if you can
```


## Model comparison

The full model is the best according to LOOIC (lowest LOOIC) and has the highest stacking weight (0.78). Removing suffix or is_sa reduces predictive performance. The interaction improves fit slightly, but may not be statistically significant on its own. The most explanatory thing in the model is the suffix types.

```{r, warning=FALSE, message=FALSE}

loos <- list(
  full           = loo(model_full),
  no_interaction = loo(model_no_interaction),
  no_sa          = loo(model_no_sa),
  no_suffix      = loo(model_no_suffix)
)

weights <- loo_model_weights(loos, method = "stacking")

loo_cmp <- loo_compare(loos)
loo_tbl <- as_tibble(loo_cmp, rownames = "Model") %>%
  rename(Delta_LOOIC = elpd_diff, SE = se_diff) %>%
  mutate(Weight = round(weights[Model], 3))


gt_table <- loo_tbl %>%
  gt() %>%
  tab_header(
    title = "Model Comparison Using LOOIC and Stacking Weights"
  ) %>%
  cols_label(
    Model = "Model",
    Delta_LOOIC = "ΔLOOIC",
    SE = "SE(ΔLOOIC)",
    looic = "LOOIC",
    se_looic = "SE(LOOIC)",
    Weight = "Stacking Weight"
  ) %>%
  fmt_number(
    columns = where(is.numeric),
    decimals = 2
  ) %>%
  data_color(
    columns = Weight,
    colors = scales::col_numeric(palette = "Blues", domain = NULL)
  ) %>%
  opt_interactive(use_search = TRUE, use_page_size_select = TRUE) %>%
  opt_row_striping() %>%
  tab_options(
    row.striping.background_color = "#f7f7f7",
    table.width = pct(100)
  )

gt_table

```


```{r, warning=FALSE, message=FALSE}
model_names <- c("Full", "No Interaction", "No SA", "No Suffix")
loo_vals <- lapply(list(model_full, model_no_interaction, model_no_sa, model_no_suffix), loo)

loo_df <- purrr::map_dfr(loo_vals, ~ {
  elpd <- .x$estimates["elpd_loo", "Estimate"]
  se <- .x$estimates["elpd_loo", "SE"]
  tibble(looic = -2 * elpd, se = 2 * se)
}, .id = "model_id")

loo_df$model <- model_names

ggplot(loo_df, aes(x = reorder(model, looic), y = looic)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = looic - se, ymax = looic + se), width = 0.2) +
  coord_flip() +
  labs(
    title = "Model Comparison via LOOIC",
    x = "Model",
    y = "LOOIC (Lower is Better)"
  ) +
  theme_minimal()

```


## The Thresholds and Posteriors


Each violin shape (e.g., labeled 1 through 5) represents the posterior distribution of a threshold:

- Threshold 1 is the cutpoint between rating 1 and 2
- Threshold 2 is between 2 and 3
- ... 
- Threshold 5 is between 5 and 6 (in a 6-point Likert, you'd get 5 thresholds)

The spacing between thresholds shows how compressed or spread out the latent intervals are:

- Small gaps (e.g., between θ2 and θ3) mean those categories (e.g., ratings 2–3) are harder to distinguish on the latent scale.
- Large gaps (e.g., θ4 to θ5) suggest a clearer transition on the latent scale (e.g., from “somewhat good” to “very good”).

```{r, warning=FALSE, message=FALSE}
model_full %>%
  spread_draws(`b_Intercept[1]`, `b_Intercept[2]`, `b_Intercept[3]`, `b_Intercept[4]`, `b_Intercept[5]`) %>%
  pivot_longer(cols = starts_with("b_Intercept"), names_to = "threshold", values_to = "value") %>%
  mutate(threshold_num = str_extract(threshold, "\\d+") %>% as.integer()) %>%
  ggplot(aes(x = threshold_num, y = value)) +
  stat_halfeye(.width = c(.66, .95)) +
  scale_x_continuous(breaks = 1:5, labels = paste("θ", 1:5)) +
  labs(
    x = "Threshold",
    y = "Latent Rating Location (logit scale)",
    title = "Posterior Distributions of Ordinal Thresholds"
  ) +
  theme_minimal()
```

Underlying latent variable (acceptability/preference) is reasonable and well-behaved. As predicted it is ordinal and in increasing manner. Given that these are mostly healthy, we can intepret predictors as shifting the latent variable down or up. In other words, if something has a positive bayesian value, it means that it is going to push the latent variable up, and thus the rating will be binned in a higher rating, given that it passes another threshold. 


```{r, warning=FALSE, message=FALSE}
model_full %>%
  spread_draws(
    b_is_sa1, 
    b_suffixMlI, 
    b_suffixMlIk, 
    b_suffixMsIz,
    `b_is_sa1:suffixMlI`, 
    `b_is_sa1:suffixMlIk`, 
    `b_is_sa1:suffixMsIz`
  ) %>%
  select(-.chain, -.iteration, -.draw) %>%  # remove draw identifiers
  pivot_longer(cols = everything(), names_to = "term", values_to = "estimate") %>%
  ggplot(aes(x = estimate, y = reorder(term, estimate))) +
  stat_halfeye(.width = c(.66, .95)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x = "Effect (log odds)",
    y = "Coefficient",
    title = "Posterior Distributions of Coefficients"
  ) +
  theme_minimal()
```

- Both -lI and -sIz strongly increase the latent rating (i.e., sentences with these suffixes are rated more positively on average).
- SA tends to increase ratings slightly, but the CI includes 0, so not conclusive on its own.
- b_is_sa1:suffixMsIz `~` 0.77
  - Suspension amplifies the positive effect of -sIz.
  - 95% CI = [0.17, 1.37] --> Credible evidence of interaction.
- b_is_sa1:suffixMlI `~` 0.03:
  - No strong interaction: suspension doesn't do much when -lI is already present.
  - Flat posterior centered around 0.
- b_is_sa1:suffixMlIk `~` -0.41:
  - Weak evidence that suspension might lower ratings with -lIk, but the CI [–0.99, 0.19] includes 0.